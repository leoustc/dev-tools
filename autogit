#!/bin/bash

# Configuration
DEV_BRANCH_NAME="dev"
MAIN_BRANCH="main"
# CRITICAL: Define the hidden namespace path
HIDDEN_REF_PATH="refs/hidden/${DEV_BRANCH_NAME}"
TIMESTAMP=$(TZ='America/Los_Angeles' date "+%s")

# --- Helper Functions ---

# Function to check out or create the local dev branch
checkout_dev() {
    LOCAL_DEV_BRANCH="${DEV_BRANCH_NAME}"
    REMOTE_REF="${HIDDEN_REF_PATH}" 
    
    if ! git rev-parse --verify ${LOCAL_DEV_BRANCH} >/dev/null 2>&1; then
        # Local branch doesn't exist. Try to fetch the hidden remote ref to create it.
        if ! git fetch origin "${REMOTE_REF}:${LOCAL_DEV_BRANCH}" >/dev/null 2>&1; then
             # If remote hidden ref doesn't exist (first push), create a local branch from main
             echo "‚ö†Ô∏è Hidden remote ref not found. Creating local branch **${LOCAL_DEV_BRANCH}** from **${MAIN_BRANCH}**."
             git checkout ${MAIN_BRANCH} || exit 1
             git checkout -b ${LOCAL_DEV_BRANCH} || exit 1
        fi
        echo "‚ú® Started new development cycle on: **${LOCAL_DEV_BRANCH}**"
    fi
    
    git checkout ${LOCAL_DEV_BRANCH} || exit 1
}

# ----------------------------------------------------
## üöÄ Push (Commit & Push to Hidden Ref)
# ----------------------------------------------------
push_dev() {
    LOCAL_DEV_BRANCH="${DEV_BRANCH_NAME}"
    REMOTE_REF="${HIDDEN_REF_PATH}" 
    INITIAL_COMMIT_MSG="Dev Cycle Started: ${TIMESTAMP}"

    echo "‚û°Ô∏è Checking out or creating development branch: **${LOCAL_DEV_BRANCH}**"
    checkout_dev

    echo "üèóÔ∏è Staging all local changes..."
    git add .
    
    DEV_AHEAD_COUNT=$(git rev-list --count ${MAIN_BRANCH}..HEAD 2>/dev/null || echo 0)
    
    if [ "$DEV_AHEAD_COUNT" -eq 0 ]; then
        # No dev-only commits yet; create a fresh dev commit instead of mutating main's tip
        echo "üìù Creating initial dev commit with message: '${INITIAL_COMMIT_MSG}'"
        git commit -m "${INITIAL_COMMIT_MSG}" || { echo "‚ö†Ô∏è No changes to commit."; }
    else
        # Subsequent pushes hide local history by amending the existing dev commit
        echo "üìù Amending previous dev commit to hide local history (message preserved)."
        git commit --amend --no-edit || { echo "‚ö†Ô∏è No changes to amend."; }
    fi
    
    # Force push the local branch HEAD to the HIDDEN remote reference
    echo "‚è´ Force pushing changes to hidden remote ref: **${REMOTE_REF}**..."
    git push --force origin "HEAD:${REMOTE_REF}" || exit 1
    
    echo "‚úÖ Development push complete. Access via hidden ref is enabled."

    git branch -v
}

# ----------------------------------------------------
## ‚¨áÔ∏è Pull (Sync from Hidden Ref)
# ----------------------------------------------------
pull_dev() {
    LOCAL_DEV_BRANCH="${DEV_BRANCH_NAME}"
    REMOTE_REF="${HIDDEN_REF_PATH}"

    # Protect against deleting local work if dirty
    if [[ -n "$(git status --porcelain)" ]]; then
        echo "‚ùå Working tree not clean."
        echo "   Detect local change; please commit it via 'autogit push' or"
        echo "   run 'git reset --hard' to clean before pulling."
        exit 1
    fi

    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    if [[ "${CURRENT_BRANCH}" == "${LOCAL_DEV_BRANCH}" ]]; then
        echo "‚û°Ô∏è Moving to **${MAIN_BRANCH}** temporarily before deletion..."
        git checkout ${MAIN_BRANCH} || { echo "‚ùå Could not checkout **${MAIN_BRANCH}**."; exit 1; }
    fi

    if git rev-parse --verify ${LOCAL_DEV_BRANCH} >/dev/null 2>&1; then
        echo "üóëÔ∏è Deleting existing local branch: **${LOCAL_DEV_BRANCH}**"
        git branch -D ${LOCAL_DEV_BRANCH}
    fi

    echo "‚¨áÔ∏è Fetching and checking out fresh local branch from hidden remote ref: **${REMOTE_REF}**"
    
    if git fetch origin "${REMOTE_REF}:${LOCAL_DEV_BRANCH}" >/dev/null 2>&1; then
        git checkout ${LOCAL_DEV_BRANCH}
        echo "‚úÖ Pulled and checked out local branch **${LOCAL_DEV_BRANCH}**."
    else
        echo "‚ùå Remote hidden reference **${REMOTE_REF}** not found. Please run 'autogit push' first."
        exit 1
    fi

    git branch -v
}

# ----------------------------------------------------
## üö¢ Release (Squash dev onto main, keep history, reset hidden seed)
# ----------------------------------------------------
release() {
    LOCAL_SOURCE_BRANCH="${DEV_BRANCH_NAME}"
    REMOTE_TARGET_BRANCH="${MAIN_BRANCH}"
    REMOTE_NAME="origin"

    echo "=========================================================="
    echo "üîê Release: squash '${LOCAL_SOURCE_BRANCH}' onto '${REMOTE_TARGET_BRANCH}' and keep history"
    echo "=========================================================="

    # Ensure clean working tree
    if [[ -n "$(git status --porcelain)" ]]; then
        echo "‚ùå Working tree not clean. Commit/stash changes before releasing."
        exit 1
    fi

    # Ensure source branch exists
    if ! git rev-parse --verify ${LOCAL_SOURCE_BRANCH} >/dev/null 2>&1; then
        echo "‚ùå Error: Local source branch **${LOCAL_SOURCE_BRANCH}** not found."
        exit 1
    fi

    # Make sure main is checked out
    git checkout ${REMOTE_TARGET_BRANCH} || { echo "‚ùå Failed to checkout **${REMOTE_TARGET_BRANCH}**."; exit 1; }
    echo "‚û°Ô∏è Switched to branch: **${REMOTE_TARGET_BRANCH}**"

    # Squash-merge dev content onto main tip
    echo "üîÑ Squashing **${LOCAL_SOURCE_BRANCH}** into **${REMOTE_TARGET_BRANCH}**..."
    if ! git merge --squash ${LOCAL_SOURCE_BRANCH}; then
        echo "‚ùå Squash merge failed. Resolve conflicts and retry."
        exit 1
    fi

    if [[ -z "$(git status --porcelain)" ]]; then
        echo "‚ö†Ô∏è No changes to commit from **${LOCAL_SOURCE_BRANCH}**. Aborting release."
        git merge --abort >/dev/null 2>&1
        exit 1
    fi

    # Get final commit message from user
    read -p "Enter the **FINAL** commit message for **${REMOTE_TARGET_BRANCH}**: " FINAL_COMMIT_MSG
    if [[ -z "${FINAL_COMMIT_MSG}" ]]; then
        echo "‚ùå Commit message cannot be empty. Aborting."
        git reset --hard HEAD >/dev/null 2>&1
        exit 1
    fi

    echo "üìù Creating release commit with message: '${FINAL_COMMIT_MSG}'"
    if ! git commit -m "${FINAL_COMMIT_MSG}"; then
        echo "‚ùå Commit failed."
        exit 1
    fi

    # Push main with new release commit
    echo "üöÄ Pushing **${REMOTE_TARGET_BRANCH}** to **${REMOTE_NAME}**..."
    if ! git push ${REMOTE_NAME} ${REMOTE_TARGET_BRANCH}; then
        echo "‚ùå Push failed."
        exit 1
    fi

    # Reset hidden ref seed to released main
    echo "üß≠ Resetting hidden ref seed to **${REMOTE_TARGET_BRANCH}**..."
    if ! git push --force ${REMOTE_NAME} ${REMOTE_TARGET_BRANCH}:${HIDDEN_REF_PATH}; then
        echo "‚ùå Failed to reset hidden ref seed."
        exit 1
    fi

    # Start new dev cycle from fresh main
    echo "üßπ Cleaning up local dev branch for next cycle..."
    if git rev-parse --verify ${LOCAL_SOURCE_BRANCH} >/dev/null 2>&1; then
        git branch -D ${LOCAL_SOURCE_BRANCH}
    fi
    echo "‚úÖ Release complete. Hidden ref now mirrors ${REMOTE_TARGET_BRANCH}."

    git branch -v
}

# ----------------------------------------------------
## üõ†Ô∏è Install / Update (copy script to /usr/local/bin)
# ----------------------------------------------------
install_or_update() {
    TARGET="/usr/local/bin/autogit"
    SCRIPT_PATH="$(readlink -f "$0" 2>/dev/null || realpath "$0")"

    if [[ -z "${SCRIPT_PATH}" ]]; then
        echo "‚ùå Could not resolve script path for installation."
        exit 1
    fi

    echo "üì¶ Installing/updating autogit to ${TARGET}..."
    if cp "${SCRIPT_PATH}" "${TARGET}" && chmod +x "${TARGET}"; then
        echo "‚úÖ Installed/updated ${TARGET}"
    else
        echo "‚ùå Failed to write to ${TARGET}. Try running with sudo."
        exit 1
    fi
}

# --- Script Execution ---

if [ $# -eq 0 ]; then
    echo "Usage: $0 {push|pull|release|install|update}"
    exit 1
fi

COMMAND="$1"

if [ "${COMMAND}" == "push" ]; then
    push_dev
elif [ "${COMMAND}" == "pull" ]; then
    pull_dev
elif [ "${COMMAND}" == "release" ]; then
    release
elif [ "${COMMAND}" == "install" ] || [ "${COMMAND}" == "update" ]; then
    install_or_update
else
    echo "Usage: $0 {push|pull|release|install|update}"
    exit 1
fi
