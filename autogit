#!/bin/bash

# Configuration
DEV_BRANCH_NAME="dev"
MAIN_BRANCH="main"
# CRITICAL: Define the hidden namespace path
HIDDEN_REF_PATH="refs/hidden/${DEV_BRANCH_NAME}"

# --- Helper Functions ---

# Function to check out or create the local dev branch
checkout_dev() {
    LOCAL_DEV_BRANCH="${DEV_BRANCH_NAME}"
    REMOTE_REF="${HIDDEN_REF_PATH}" 
    
    if ! git rev-parse --verify ${LOCAL_DEV_BRANCH} >/dev/null 2>&1; then
        # Local branch doesn't exist. Try to fetch the hidden remote ref to create it.
        if ! git fetch origin "${REMOTE_REF}:${LOCAL_DEV_BRANCH}" >/dev/null 2>&1; then
             # If remote hidden ref doesn't exist (first push), create a local branch from main
             echo "âš ï¸ Hidden remote ref not found. Creating local branch **${LOCAL_DEV_BRANCH}** from **${MAIN_BRANCH}**."
             git checkout ${MAIN_BRANCH} || exit 1
             git checkout -b ${LOCAL_DEV_BRANCH} || exit 1
        fi
        echo "âœ¨ Started new development cycle on: **${LOCAL_DEV_BRANCH}**"
    fi
    
    git checkout ${LOCAL_DEV_BRANCH} || exit 1
}

# ----------------------------------------------------
## ðŸš€ Push (Commit & Push to Hidden Ref)
# ----------------------------------------------------
push_dev() {
    LOCAL_DEV_BRANCH="${DEV_BRANCH_NAME}"
    REMOTE_REF="${HIDDEN_REF_PATH}" 
    INITIAL_COMMIT_MSG="Dev Cycle Started: $(date +%Y-%m-%d %H:%M:%S)"

    echo "âž¡ï¸ Checking out or creating development branch: **${LOCAL_DEV_BRANCH}**"
    checkout_dev

    echo "ðŸ—ï¸ Staging all local changes..."
    git add .
    
    DEV_AHEAD_COUNT=$(git rev-list --count ${MAIN_BRANCH}..HEAD 2>/dev/null || echo 0)
    
    if [ "$DEV_AHEAD_COUNT" -eq 0 ]; then
        # No dev-only commits yet; create a fresh dev commit instead of mutating main's tip
        echo "ðŸ“ Creating initial dev commit with message: '${INITIAL_COMMIT_MSG}'"
        git commit -m "${INITIAL_COMMIT_MSG}" || { echo "âš ï¸ No changes to commit."; }
    else
        # Subsequent pushes hide local history by amending the existing dev commit
        echo "ðŸ“ Amending previous dev commit to hide local history (message preserved)."
        git commit --amend --no-edit || { echo "âš ï¸ No changes to amend."; }
    fi
    
    # Force push the local branch HEAD to the HIDDEN remote reference
    echo "â« Force pushing changes to hidden remote ref: **${REMOTE_REF}**..."
    git push --force origin "HEAD:${REMOTE_REF}" || exit 1
    
    echo "âœ… Development push complete. Access via hidden ref is enabled."
}

# ----------------------------------------------------
## â¬‡ï¸ Pull (Sync from Hidden Ref)
# ----------------------------------------------------
pull_dev() {
    LOCAL_DEV_BRANCH="${DEV_BRANCH_NAME}"
    REMOTE_REF="${HIDDEN_REF_PATH}"

    # Protect against deleting local work if dirty
    if [[ -n "$(git status --porcelain)" ]]; then
        echo "âŒ Working tree not clean. Commit/stash changes before pulling dev."
        exit 1
    fi

    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    if [[ "${CURRENT_BRANCH}" == "${LOCAL_DEV_BRANCH}" ]]; then
        echo "âž¡ï¸ Moving to **${MAIN_BRANCH}** temporarily before deletion..."
        git checkout ${MAIN_BRANCH} || { echo "âŒ Could not checkout **${MAIN_BRANCH}**."; exit 1; }
    fi

    if git rev-parse --verify ${LOCAL_DEV_BRANCH} >/dev/null 2>&1; then
        echo "ðŸ—‘ï¸ Deleting existing local branch: **${LOCAL_DEV_BRANCH}**"
        git branch -D ${LOCAL_DEV_BRANCH}
    fi

    echo "â¬‡ï¸ Fetching and checking out fresh local branch from hidden remote ref: **${REMOTE_REF}**"
    
    if git fetch origin "${REMOTE_REF}:${LOCAL_DEV_BRANCH}" >/dev/null 2>&1; then
        git checkout ${LOCAL_DEV_BRANCH}
        echo "âœ… Pulled and checked out local branch **${LOCAL_DEV_BRANCH}**."
    else
        echo "âŒ Remote hidden reference **${REMOTE_REF}** not found. Please run 'autogit push' first."
        exit 1
    fi
}

# ----------------------------------------------------
## ðŸš¢ Release (Squash dev onto main, keep history, reset hidden seed)
# ----------------------------------------------------
release() {
    LOCAL_SOURCE_BRANCH="${DEV_BRANCH_NAME}"
    REMOTE_TARGET_BRANCH="${MAIN_BRANCH}"
    REMOTE_NAME="origin"

    echo "=========================================================="
    echo "ðŸ” Release: squash '${LOCAL_SOURCE_BRANCH}' onto '${REMOTE_TARGET_BRANCH}' and keep history"
    echo "=========================================================="

    # Ensure clean working tree
    if [[ -n "$(git status --porcelain)" ]]; then
        echo "âŒ Working tree not clean. Commit/stash changes before releasing."
        exit 1
    fi

    # Ensure source branch exists
    if ! git rev-parse --verify ${LOCAL_SOURCE_BRANCH} >/dev/null 2>&1; then
        echo "âŒ Error: Local source branch **${LOCAL_SOURCE_BRANCH}** not found."
        exit 1
    fi

    # Make sure main is checked out
    git checkout ${REMOTE_TARGET_BRANCH} || { echo "âŒ Failed to checkout **${REMOTE_TARGET_BRANCH}**."; exit 1; }
    echo "âž¡ï¸ Switched to branch: **${REMOTE_TARGET_BRANCH}**"

    # Squash-merge dev content onto main tip
    echo "ðŸ”„ Squashing **${LOCAL_SOURCE_BRANCH}** into **${REMOTE_TARGET_BRANCH}**..."
    if ! git merge --squash ${LOCAL_SOURCE_BRANCH}; then
        echo "âŒ Squash merge failed. Resolve conflicts and retry."
        exit 1
    fi

    if [[ -z "$(git status --porcelain)" ]]; then
        echo "âš ï¸ No changes to commit from **${LOCAL_SOURCE_BRANCH}**. Aborting release."
        git merge --abort >/dev/null 2>&1
        exit 1
    fi

    # Get final commit message from user
    read -p "Enter the **FINAL** commit message for **${REMOTE_TARGET_BRANCH}**: " FINAL_COMMIT_MSG
    if [[ -z "${FINAL_COMMIT_MSG}" ]]; then
        echo "âŒ Commit message cannot be empty. Aborting."
        git reset --hard HEAD >/dev/null 2>&1
        exit 1
    fi

    echo "ðŸ“ Creating release commit with message: '${FINAL_COMMIT_MSG}'"
    if ! git commit -m "${FINAL_COMMIT_MSG}"; then
        echo "âŒ Commit failed."
        exit 1
    fi

    # Push main with new release commit
    echo "ðŸš€ Pushing **${REMOTE_TARGET_BRANCH}** to **${REMOTE_NAME}**..."
    if ! git push ${REMOTE_NAME} ${REMOTE_TARGET_BRANCH}; then
        echo "âŒ Push failed."
        exit 1
    fi

    # Reset hidden ref seed to released main
    echo "ðŸ§­ Resetting hidden ref seed to **${REMOTE_TARGET_BRANCH}**..."
    if ! git push --force ${REMOTE_NAME} ${REMOTE_TARGET_BRANCH}:${HIDDEN_REF_PATH}; then
        echo "âŒ Failed to reset hidden ref seed."
        exit 1
    fi

    # Start new dev cycle from fresh main
    echo "ðŸ§¹ Cleaning up local dev branch for next cycle..."
    if git rev-parse --verify ${LOCAL_SOURCE_BRANCH} >/dev/null 2>&1; then
        git branch -D ${LOCAL_SOURCE_BRANCH}
    fi
    echo "âœ… Release complete. Hidden ref now mirrors ${REMOTE_TARGET_BRANCH}."
}

# --- Script Execution ---

if [ $# -eq 0 ]; then
    echo "Usage: $0 {push|pull|release}"
    exit 1
fi

COMMAND="$1"

if [ "${COMMAND}" == "push" ]; then
    push_dev
elif [ "${COMMAND}" == "pull" ]; then
    pull_dev
elif [ "${COMMAND}" == "release" ]; then
    release
else
    echo "Usage: $0 {push|pull|release}"
    exit 1
fi
